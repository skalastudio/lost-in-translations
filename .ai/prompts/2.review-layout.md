# Prompt
You are a senior macOS engineer and UX designer with deep knowledge of Apple Human Interface Guidelines.

Redesign the macOS app ‚ÄúLost in Translations‚Äù, a language translation and writing assistant, to follow Apple‚Äôs standard macOS application layout and interaction patterns.

Context:
- Lost in Translations helps users translate text, improve sentences, rephrase content, and find synonyms.
- The app supports multiple LLM providers (e.g. OpenAI, Claude, Gemini) using user-provided API keys.
- The app is a normal macOS app (NOT a menu bar app).
- Target platform: macOS 14+
- Tech stack: Swift, SwiftUI, Apple frameworks only.

Design goals:
- Follow Apple‚Äôs recommended layout: Sidebar + Content Area
- Use NavigationSplitView as the primary window structure
- Feel native, calm, and professional (similar to Apple Notes, Mail, DeepL for Mac)
- Optimize for text-heavy workflows
- Avoid web-style layouts or custom navigation patterns

Layout requirements:
1. Main window uses NavigationSplitView with:
   - Left sidebar for high-level navigation (modes)
   - Right content area for the primary task

2. Sidebar (List with .sidebar style):
   - Items:
     - Translate
     - Improve Text
     - Rephrase
     - Synonyms
     - (Optional) History
   - Uses SF Symbols
   - No forms, no controls, navigation only

3. Content area:
   - Changes based on selected sidebar mode
   - Translate mode:
     - Top toolbar with:
       - Source language (Auto by default)
       - Target language pills (2‚Äì3 max)
       - Intent selector (Email, Chat, Notes, etc.)
       - Tone selector (Neutral, Formal, Casual, etc.)
       - Optional model picker (collapsed by default)
     - Main content uses a split view:
       - Left: input text editor
       - Right: output area showing translated text side-by-side per language
     - Output cards include actions: Copy, Replace input, Regenerate

   - Improve / Rephrase modes:
     - Single-language workflow
     - Input ‚Üí Improved/Rephrased output
     - Optional refinement actions (shorter, more formal, etc.)

   - Synonyms mode:
     - Word or phrase input
     - Output panel showing synonyms, usage notes, and examples

4. Toolbar:
   - Uses unified toolbar
   - Contextual to the selected mode
   - No navigation inside the toolbar

5. Settings:
   - Separate Settings window (Cmd + ,)
   - Tabs:
     - General
     - Providers (API keys)
     - Models
     - Output
     - Privacy
   - All processing is local; no server-side storage

Implementation expectations:
- Provide:
  - A high-level SwiftUI view hierarchy
  - NavigationSplitView structure
  - Sidebar implementation
  - Content view switching per mode
  - Toolbar configuration per mode
- Follow Apple naming conventions and SwiftUI best practices
- Do not include third-party UI frameworks
- Prioritize clarity and maintainability over cleverness

Output format:
- Brief architecture explanation
- SwiftUI code skeletons (not full implementations)
- Clear separation of views and responsibilities

# Splitted Prompts 

After each prompt, add one sentence like:
> Note: ‚ÄúOnly modify/introduce the files needed. Keep the code compilable.‚Äù

----

## Prompt Split @1 - Plan + file structure (no code yet)

You are a senior macOS SwiftUI engineer. I‚Äôm redesigning my app ‚ÄúLost in Translations‚Äù into a normal macOS app (not menu bar). Target macOS 14+.

Goal: Apple-standard layout (sidebar + content) using NavigationSplitView.

First, propose:
1) the main user flows (Translate / Improve / Rephrase / Synonyms / History optional)
2) a recommended SwiftUI file structure (folders + key views)
3) what state models/enums you would create (e.g., AppMode, Provider, Intent, Tone)
Do not write code yet. Keep it concise and Apple-HIG aligned.

----

## Prompt Split @2 - Create the NavigationSplitView shell (code skeleton)

Implement the main window skeleton in SwiftUI using NavigationSplitView.

Requirements:
- Sidebar uses a List with .sidebar style
- Sidebar items: Translate, Improve Text, Rephrase, Synonyms, (optional) History
- Use SF Symbols for each item
- Selecting an item switches the content view in the detail area
- Create an AppMode enum and selection binding
- Provide compilable SwiftUI code for:
  - LostInTranslationsApp.swift (or main entry)
  - RootView with NavigationSplitView
  - SidebarView
  - Placeholder detail views per mode (simple Text for now)
No third-party frameworks.

----

## Prompt @3 - Add unified toolbar that changes by mode

Add a unified toolbar to the NavigationSplitView detail area.

Requirements:
- Toolbar is contextual: show different toolbar items depending on selected AppMode
- Translate mode toolbar items:
  - From language (Auto default)
  - Target languages as pills (max 3) + add button
  - Intent menu (Email, SMS, Chat, Notes)
  - Tone menu (Neutral, Professional, Formal, Casual, Friendly, Direct)
  - Optional model picker hidden behind a Menu or ‚ÄúAdvanced‚Äù popover
- Other modes can have minimal toolbar actions for now (e.g., Clear, Copy)
Provide SwiftUI code updates only (no long explanations).

----

## Prompt @4 - Translate mode UI (split editors + output cards)

Implement TranslateModeView UI in SwiftUI (UI only, no networking).

Layout:
- Use a horizontal split: left input editor, right output panel
- Left: TextEditor with placeholder behavior (SwiftUI-friendly)
- Right: output shows 2‚Äì3 language result cards stacked vertically
- Each output card includes:
  - language label (e.g., ‚Äúüáµüáπ Portuguese‚Äù)
  - read-only text view area (can be TextEditor disabled or ScrollView Text)
  - buttons: Copy, Replace input, Regenerate (actions stubbed)
- Provide a simple in-memory model for outputs:
  - [TranslationOutput] where each has language + text
- Add keyboard shortcuts:
  - Cmd+Enter triggers ‚ÄúTranslate‚Äù action (stub)
  - Cmd+Shift+C copies all outputs (stub)
Make it feel native (padding, alignment, no flashy styling).

----

## Prompt @5 - Improve Text mode UI

Implement ImproveTextModeView UI (UI only).

Requirements:
- Two-pane vertical layout (or left/right, your choice) that feels macOS-native:
  - Original input TextEditor
  - Improved output area
- Provide quick refinement buttons (stub actions):
  - Shorter
  - More formal
  - More friendly
- Include Copy + Replace actions for output
- Keep controls minimal; toolbar already contains Tone selector
Return SwiftUI code for ImproveTextModeView and any small supporting structs.

----

## Prompt @6 - Rephrase mode UI

Implement RephraseModeView UI (UI only).

Requirements:
- Similar to ImproveTextModeView but focused on ‚Äúsame meaning, different phrasing‚Äù
- Add a Variants toggle:
  - Off: show one rephrase result
  - On: show 3 variant cards stacked (stub data)
- Provide Copy / Replace per variant
Return SwiftUI code only.

----

## Prompt @7 ‚Äî Synonyms mode UI

Implement SynonymsModeView UI (UI only).

Requirements:
- Top input for a single word or short phrase (TextField)
- Right/detail area shows:
  - list of synonyms
  - short usage notes (placeholder)
  - example sentences (placeholder)
- Add actions: Copy selected synonym, Insert into clipboard (stub)
Make it look like a macOS utility inside a standard app window.
Return SwiftUI code only.

----

## Prompt @8 ‚Äî Settings window (Cmd+,) with tabs

Add a Settings window (Cmd+,) in SwiftUI.

Requirements:
- Use Settings scene (SwiftUI App) with a TabView
- Tabs:
  - General
  - Providers (API keys)
  - Models
  - Output
  - Privacy
- Providers tab:
  - sections for OpenAI / Claude / Gemini
  - secure fields + ‚ÄúSave‚Äù (store in Keychain if you can; otherwise stub with in-memory + TODO)
- Privacy tab:
  - text explaining local processing
  - toggle ‚ÄúStore History locally‚Äù
Return SwiftUI code. Use Apple frameworks only.

----

## Prompt @9 ‚Äî History (optional) local-only stubs

Add an optional History mode.

Requirements:
- Store history items locally (simple JSON in Application Support is ok; SwiftData optional)
- A history list view with:
  - first line preview
  - mode
  - date/time
- Selecting an item restores the input text and outputs into the relevant mode view (stub if needed)
Return code plus brief notes on where you persist data.
